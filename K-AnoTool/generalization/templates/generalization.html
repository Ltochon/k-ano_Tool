{% extends "base.html" %}
{% block body %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js"></script>

<script>
let nblvl = 0;

var treeData = [
  {
    "name": "Level 0 : *",
    "parent": "null",
  }
];


// ************** Generate the tree diagram	 *****************
var margin = {top: 20, right: 120, bottom: 20, left: 120},
	width = 960 - margin.right - margin.left,
	height = 500 - margin.top - margin.bottom;
	
var i = 0,
	duration = 750,
	root;

var tree = d3.layout.tree()
	.size([height, width]);
var diagonal = d3.svg.diagonal()
	.projection(function(d) { return [d.y, d.x]; });

var svg = d3.select("body").append("svg")
	.attr("width", width + margin.right + margin.left)
	.attr("height", height + margin.top + margin.bottom)
  .append("g")
	.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

document.body.addEventListener("contextmenu",(e) =>{e.preventDefault()})

d3.select(self.frameElement).style("height", "500px");

function update(source) {
  // Compute the new tree layout.
  var nodes = tree.nodes(root).reverse(),
	  links = tree.links(nodes);
  // Normalize for fixed-depth.
  let tabdepth = [];
  nodes.forEach(function(d) { d.y = d.depth * 100; tabdepth.push(d.depth);});
  //remove labal and inputs
  if(Math.max(...tabdepth) < nblvl){
    while(nblvl > Math.max(...tabdepth)){
      nblvl--;
      let lbltoremove = document.getElementById("lbl" + nblvl.toString());
      let inptoremove = document.getElementById("inp" + nblvl.toString());
      let d = document.getElementById("inplvl");
      d.removeChild(lbltoremove);
      d.removeChild(inptoremove);
    }
  }
  else{
    while(nblvl < Math.max(...tabdepth)){
      nblvl++;
      createinp(nblvl);
    }
  }
  
  if(localStorage.getItem("weights_" + localStorage.getItem("qid").replace("hiera_",'')) != null){
    let l = 0;
    while(l < nblvl){
      document.getElementById("inp" + l.toString()).value = localStorage.getItem("weights_" + localStorage.getItem("qid").replace("hiera_",'')).split(',')[l]; 
      l++;     
    }
  }

  // Update the nodes…
  var node = svg.selectAll("g.node")
	  .data(nodes, function(d) { return d.id || (d.id = ++firstid); })
  // Enter any new nodes at the parent's previous position.
  var nodeEnter = node.enter().append("g")
	  .attr("class", "node")
	  .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
	  .on("click", click)

  nodeEnter.append("circle")
	  .attr("r", 1e-6)
	  .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

  nodeEnter.append("text")
	  .attr("x", function(d) { return d.children || d._children ? -13 : 13; })
	  .attr("dy", ".35em")
	  .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
	  .text(function(d) { return d.name; })
	  .style("fill-opacity", 1e-6);

  // Transition nodes to their new position.
  var nodeUpdate = node.transition()
	  .duration(duration)
	  .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

  nodeUpdate.select("circle")
	  .attr("r", 10)
	  .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

  nodeUpdate.select("text")
	  .style("fill-opacity", 1);

  // Transition exiting nodes to the parent's new position.
  var nodeExit = node.exit().transition()
	  .duration(duration)
	  .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
	  .remove();

  nodeExit.select("circle")
	  .attr("r", 1e-6);

  nodeExit.select("text")
	  .style("fill-opacity", 1e-6);

  // Update the links…
  var link = svg.selectAll("path.link")
	  .data(links, function(d) { return d.target.id; });

  // Enter any new links at the parent's previous position.
  link.enter().insert("path", "g")
	  .attr("class", "link")
	  .attr("d", function(d) {
		var o = {x: source.x0, y: source.y0};
		return diagonal({source: o, target: o});
	  })
  
  // Transition links to their new position.
  link.transition()
	  .duration(duration)
	  .attr("d", diagonal);
  
  // Transition exiting nodes to the parent's new position.
  link.exit().transition()
	  .duration(duration)
	  .attr("d", function(d) {
		var o = {x: source.x, y: source.y};
		return diagonal({source: o, target: o});
	  })
	  .remove();
  

  // Stash the old positions for transition.
  nodes.forEach(function(d) {
	d.x0 = d.x;
	d.y0 = d.y;
  });
}

// Toggle children on click.

var pointerX = -1;
var pointerY = -1;
document.onmousemove = function(event) {
	pointerX = event.pageX;
	pointerY = event.pageY;
}

function createinp(nblvl){
  let lab = document.createElement("label");
  lab.classList.add("labellvl");
  lab.setAttribute("id","lbl" + (nblvl-1).toString());
  lab.innerHTML = "Level " + (nblvl-1).toString() + " to " + (nblvl).toString();
  let inp = document.createElement("input");
  inp.type = "number";
  inp.classList.add("inputlvl");
  inp.addEventListener("change",saveweights)
  inp.setAttribute("id","inp" + (nblvl-1).toString())
  document.getElementById("inplvl").appendChild(lab);
  document.getElementById("inplvl").appendChild(inp);
}

function add(child,parent){
  if(parseInt(d_copy.depth) + 1 > nblvl){
    nblvl++;
    createinp(nblvl);
  }
  if(d_copy["children"] == undefined){
    d_copy["children"] = [{"name": "Level "+ (parseInt(d_copy.depth) + 1).toString()}]
  }
  else{
    d_copy.children.push({
              "name": "Level "+ (parseInt(d_copy.depth) + 1).toString()
            });
  }
  update(d_copy);
  document.getElementById("hiddenactions").hidden = true;
}

function remove(){
  for(elem in d_copy.parent.children){
    if(d_copy.parent.children[elem].name == d_copy.name){
      d_copy.parent.children.splice(elem,1)
    }
  }
  update(d_copy);
  document.getElementById("hiddenactions").hidden = true;
}

let d_copy;
function click(d) {
  d_copy = d;
  if(document.getElementById("edit").checked){
    document.getElementById("hiddenactions").hidden = false;
    document.getElementById("hiddenactions").style.top = pointerY-70+"px";
    document.getElementById("hiddenactions").style.left = pointerX+3+"px";
  }
  else{
    if (d.children) {
    d._children = d.children;
    d.children = null;
    } else {
    d.children = d._children;
    d._children = null;
    }
    update(d);
  }
}

function saveweights(){
  j = 0;
    tabweight = []
    while(j < nblvl){
      let inptosave = document.getElementById("inp"+j.toString()).value;
      tabweight.push(inptosave);
      j++;
    }
    localStorage.setItem("weights_" + localStorage.getItem("qid").replace("hiera_",''),tabweight);
}

var sub = (function(){
    var savenodes = tree.nodes(root).reverse(),links = tree.links(savenodes);
    allnodes = savenodes.reverse()
    tabtosave = [];
    for(elem in allnodes){
      if(elem == 0){
        tabtosave.push([allnodes[elem].name,allnodes[elem].id,"0",allnodes[elem].depth])
      }
      else{
        tabtosave.push([allnodes[elem].name,allnodes[elem].id,allnodes[elem].parent.id,allnodes[elem].depth])
      }
    }
    localStorage.setItem("tree_" + localStorage.getItem("qid").replace("hiera_",''),JSON.stringify(tabtosave));
    saveweights();
  });

</script>
<div id="hiddenactions" style="padding: 0.2em; width : 3.4em; height:50px; position: absolute;" hidden>
  <button style="width: 5em; height: 30px; margin-bottom: 0.1em;" onclick="add()">Add</button>
  <button style="width: 5em; height: 30px;" onclick="remove()">Remove</button>
</div>
<div style="float : right; width: 20%; margin-top: 1em; margin-right: 1em;">
  <div style=" margin-bottom: 10px; margin-left: -5.5em; float: left; width: fit-content;">
    <div class="checkboxes">
      <label><input id="edit" type="checkbox" onchange="checkb(this)"> <span style="margin-right: 0.5em; font-weight: bold; color: red;">Edit tree</span></label>
    </div>
  </div>
  <div style="text-align: center;">
    <p id="qid" style="font-weight: bold; font-size: large; color : green;">a</p>
  </div>
  <div id = "inplvl" style="border: solid black 2px; padding: 1em;">
    <div style="text-align: center; font-weight: bold; color: black;">
        <span>Level's weights</span>
        <br>
    </div>
  </div>
  <div style="text-align: center;">
    <form method="POST" action="" onsubmit="sub()" enctype="multipart/form-data" >
      <input type="hidden" value="hiddenqid" name="hiddenqid" id="hiddenqid" />
      <input type="submit" value="Save" class = "submit" style="margin-top : 10px">
    </form>
    <button onclick="sub()" class = "cancel" style="margin-top : 10px">Cancel</button>
  </div>
</div>

<script>

  function list_to_tree(list) {
    var map = {}, node, roots = [], i;
    
    for (i = 0; i < list.length; i += 1) {
      map[list[i].id] = i; // initialize the map
      list[i].children = []; // initialize the children
    }
    
    for (i = 0; i < list.length; i += 1) {
      node = list[i];
      if (node.parentId !== "0") {
        // if you have dangling branches check that map[node.parentId] exists
        list[map[node.parentId]].children.push(node);
      } else {
        roots.push(node);
      }
    }
    return roots;
  }

  document.getElementById("qid").innerHTML = "QID : " + localStorage.getItem("qid").replace("hiera_",'');
  document.getElementById("hiddenqid").value = localStorage.getItem("qid").replace("hiera_",'');
  let firstid = 0;
  if(localStorage.getItem("weights_" + localStorage.getItem("qid").replace("hiera_",'')) != null){
    for(elem in localStorage.getItem("weights_" + localStorage.getItem("qid").replace("hiera_",'')).split(',')){
      createinp(parseInt(elem)+1);
      document.getElementById("inp" + elem).value = localStorage.getItem("weights_" + localStorage.getItem("qid").replace("hiera_",'')).split(',')[elem];
      nblvl++;      
    }
    var treetodisplay = JSON.parse(localStorage.getItem("tree_"+ localStorage.getItem("qid").replace("hiera_",'')));
    var toconvert = [];
    for(elem in treetodisplay){
      if(treetodisplay[elem][1] > firstid){
        firstid = treetodisplay[elem][1];
      }
      let dic = {
        "id" : treetodisplay[elem][1],
        "name" : treetodisplay[elem][0],
        "depth" : treetodisplay[elem][3],
        "children" : null,
        "parentId" : treetodisplay[elem][2]
      }
      toconvert.push(dic);
    }
    treeData = list_to_tree(toconvert);
    
  }
  else{
    var treeData = [
      {
        "name": "Level 0 : *",
        "parent": "null",
      }
    ];

    }
  root = treeData[0];
  root.x0 = height / 2;
  root.y0 = 0;

  update(root);
  
  function checkb(evt){
    if(!evt.checked){
        document.getElementById("hiddenactions").hidden = true;
    }
  }
</script>
{%endblock%}